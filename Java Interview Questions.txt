
Part 1 - (Java Platform)

Problem 1 : Why is Java so Popular?

Ans : 1. Platform Independence 
      2. Object Oriented Language
 	  3.It has large / Standard library

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 2 : Why is Java so Popular?

Ans : Java is popular because it is a versatile, platform-independent programming language that offers several key benefits like It provides a strong foundation for building robust and scalable applications due to its object-oriented nature.It has great Memory management and provides high security.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 3 : What is ByteCode?

Ans : Bytecode is a low-level, platform-independent representation of a program that is generated by a compiler. It is a set of instructions that can be executed by a virtual machine.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : Compare JDK vs JVM VS JRE.
Ans : 
JDK (Java Development Kit): It is a software development kit that includes tools needed for developing, compiling, and debugging Java applications. It contains the Java compiler (javac), the Java runtime environment (JRE), and various development tools such as debuggers and application servers.
JVM (Java Virtual Machine): It is a virtual machine that executes Java bytecode. It provides an environment where Java programs can run independently of the underlying hardware or operating system. JVM translates bytecode into machine-specific instructions and manages memory allocation and garbage collection.
JRE (Java Runtime Environment): It is an environment that provides the necessary runtime libraries and components required to run Java applications. JRE includes the JVM, class libraries, and other supporting files necessary for executing Java programs.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 5 : What is the role of class loader in java ?

Ans : The class loader in Java is responsible for loading Java classes at runtime. Its role is to locate, load, and link the classes needed by a Java program. The class loader performs loading and linking.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------



Part 2 :  (Wrapper Class)



Problem 1 : What are wrapper classes?

Ans : Wrapper classes in Java provide a way to convert primitive data types into objects. They "wrap" primitive types and provide additional functionality such as methods and constructors. Each primitive type in Java has a corresponding wrapper class:
Examples:
Integer: Wraps int, Float: Wraps float, Boolean: Wraps boolean etc

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : Why do we need Wrapper Classes in Java?

Ans : Wrapper classes in Java serve several purposes:

Conversion: Wrapper classes provide methods to convert primitive data types into objects and vice versa. This is useful when we need to pass primitive values to methods or APIs that only accept objects.

Object-oriented features: Wrapper classes allow primitive types to be used in object-oriented contexts. For example, they can be used with collections, generics, and other APIs that require objects.

Nullability: Wrapper classes can handle null values, unlike primitive types. This is important when dealing with situations where a variable may not have a value assigned.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 3 : What are the different ways of creating Wrapper Class Instances?

Ans : Using Autoboxing : 
Integer number = 10;       // Autoboxing int to Integer
Boolean flag = true;         // Autoboxing boolean to Boolean
Using valueOf() method : 
Integer number = Integer.valueOf(10);     // Creating Integer instance with value 10
Boolean flag = Boolean.valueOf(true);    // Creating Boolean instance with value true


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 4 : What is Auto Boxing?

Ans : Autoboxing: Primitive values can be assigned directly to variables of the corresponding wrapper class type, and Java will automatically wrap the value into an instance of the wrapper class. 
For example:
Integer number = 10;       // Autoboxing int to Integer
Boolean flag = true;         // Autoboxing boolean to Boolean

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 5 : What are the advantages of Auto Boxing?

Ans : The advantages of autoboxing in Java are convenience, readability, compatibility with APIs, and integration with collections and generics.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6 : What is Casting?

Ans : Casting in Java is the process of converting a value of one data type into another data type. It allows you to treat an object or a variable as another type, provided there is a compatible relationship between the types. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 7 : What is Implicit Casting?

Ans : Implicit Casting (Widening): It occurs when the target type has a larger range or precision than the source type. It is done automatically by the compiler. For example, converting an int to a double or assigning a byte value to an int.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 8 : What is Explicit Casting?

Ans :  Explicit Casting (Narrowing): It occurs when the target type has a smaller range or precision than the source type. It requires an explicit cast operator and can result in data loss or truncation. For example, converting a double to an int or assigning an int value to a byte.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------



Part 3 :  (Strings)




Problem 1 : Are all Strings immutable?

Ans : Yes, in Java, all String objects are immutable.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : Where are string values stored in memory?

Ans : String values are stored in the heap memory in Java, except for string literals which are stored in the String pool.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 3 : Why should you be careful about the String Concatenation(+) operator in Loops?

Ans : You should be careful about using the String concatenation (+) operator in loops because it can lead to inefficient memory usage and performance degradation. Each concatenation operation creates a new String object, resulting in unnecessary memory allocation and object creation. This can be particularly problematic in loops with a large number of iterations, leading to excessive memory consumption and slower execution.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 4 : How do you solve the above problem?

Ans : To avoid these issues, it is advisable to use StringBuilder or StringBuffer for efficient string concatenation within loops.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 5 : What are differences between String and StringBuffer?

Ans :  The differences between String and StringBuffer in Java are:

1.Mutability: String objects are immutable, meaning their values cannot be changed once created. StringBuffer objects, on the other hand, are mutable, allowing modification of their contents.

2.Thread-safety: String objects are inherently thread-safe because they are immutable. StringBuffer objects, however, are mutable and provide built-in synchronisation mechanisms to ensure thread-safety in multi-threaded environments.

3.API functionality: String offers a wide range of methods for string manipulation, searching, and comparison. StringBuffer provides similar functionality but also includes methods for appending, inserting, deleting, and replacing characters or substrings within the buffer.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 6 : What are differences between StringBuilder and StringBuffer?

Ans : The differences between StringBuilder and StringBuffer in Java are:

1.Thread-safety: StringBuilder is not thread-safe, meaning it is not synchronized and not suitable for concurrent access from multiple threads. StringBuffer, on the other hand, is thread-safe and includes built-in synchronization, allowing safe access from multiple threads.

2.Performance: StringBuilder is generally faster and more efficient than StringBuffer because it does not include the overhead of synchronization. If thread-safety is not a concern, StringBuilder is the preferred choice for better performance.

3.Mutable nature: Both StringBuilder and StringBuffer are mutable, allowing modification of their contents. They provide similar functionality for string manipulation, such as appending, inserting, deleting, and replacing characters or substrings within the buffer.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 7 : Can you give examples of different utility methods in String class?

Ans : Certainly! Here are a few examples of utility methods in the String class:

1.length(): Returns the length of the string.
2.charAt(int index): Returns the character at the specified index.
3.substring(int beginIndex): Returns a substring starting from the specified index.
4.substring(int beginIndex, int endIndex): Returns a substring within the specified range of indices.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------




Part 4 :  (OOPs)



Problem 1 : What is a Class?

Ans : A class is a blueprint or template in object-oriented programming that defines the properties and behaviors of objects. It serves as a structure for creating objects with specific characteristics and functionalities.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 2 : What is the state of an Object?

Ans : The state of an object refers to the current values of its attributes or instance variables, representing the data it holds at a specific moment in time.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 3 : What is the behavior of an Object?

Ans : The behavior of an object refers to the actions or operations it can perform and how it responds to requests or messages. It is defined by the methods or functions associated with the object, which encapsulate its functionality and define its behavior.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 4 : What is the superclass of every class in Java?

Ans : The superclass of every class in Java is the class called Object.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 5:  Explain about the toString method ?

Ans : The toString() method is a built-in method in Java that returns a string representation of an object. It is used to provide a meaningful and human-readable representation of the object's state. By default, it includes the class name and hash code, but it can be overridden in custom classes to provide a customised string representation. The toString() method is commonly used for debugging, logging, or displaying object information.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 6: What is the use of equals method in Java ?

Ans : The equals() method in Java is used to compare the equality of two objects based on their content or state. It returns true if the objects are considered equal and false otherwise. It is commonly used to compare objects for equality in collections, searching, and logical comparisons.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 7:  What are the important things to consider when implementing equals method?

Ans : When implementing the equals() method in Java, consider the following important points:

1.Override equals(): Override the equals() method to provide a custom comparison logic for your class.
2.Check object reference: Start by checking if the compared object is the same reference as the current object (this). If true, return true.
3.Use instanceof: Use the instanceof operator to check if the compared object is of the same class as the current object.
4.Compare attributes: Compare the attributes of both objects to determine equality. Consider using the equals() method for comparing non-primitive attributes.
5.Handle null: Handle the case where the compared object is null. Return false if null.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 8 : What is the hashCode method used for in Java?

Ans : The hashCode() method in Java is used to generate a unique integer value, known as the hash code, for an object. It is primarily used in hash-based data structures like HashMap and HashSet to efficiently store and retrieve objects. The hashCode() method ensures proper distribution and organization of objects within these data structures, allowing for fast lookup and retrieval operations.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 9 : Explain inheritance with Examples.

Ans : Inheritance is a concept in object-oriented programming where a class can inherit properties and behaviors from another class. It allows for code reuse and promotes the creation of hierarchical relationships between classes.
For Example: 
class Animal {
    protected String species;
    public void eat() {
        System.out.println("The animal is eating.");
    }
}
class Dog extends Animal {
    public void bark() {
        System.out.println("The dog is barking.");
    }
}
Dog myDog = new Dog();
myDog.species = "Canine";       // Inherited from Animal class
myDog.eat();                             // Inherited from Animal class
myDog.bark();                          // Specific to Dog class



---------------------------------------------------------------------------------------------------------------------------------------------------------------------



Problem 10 : What is Method Overloading?

Ans : Method overloading is a feature in Java that allows multiple methods to have the same name but different parameters within a class. It enables the creation of methods with similar functionality but different input parameters. The compiler determines which method to call based on the arguments provided during invocation. Method overloading helps improve code readability and flexibility by providing multiple ways to perform a similar operation with varying inputs.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 11 : What is Method Overriding?

Ans : Method overriding is a feature in Java where a subclass provides a different implementation of a method that is already defined in its superclass. It allows the subclass to modify or extend the behavior inherited from the superclass. The method in the subclass must have the same name, return type, and parameter list as the method in the superclass.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 12 : Can super class reference variables hold an object of subclass?

Ans : Yes, a superclass reference variable can hold an object of its subclass. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 13 : Is Multiple Inheritance allowed in Java?

Ans : No, multiple inheritance is not allowed in Java. Java supports single inheritance, which means a class can inherit from only one superclass. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 14 : What is an Interface ?

Ans : An interface in Java is a contract or blueprint that defines a set of abstract methods that a class must implement. It specifies the behavior that a class should have without providing the implementation details. Interfaces allow for achieving abstraction, defining common behavior, and supporting multiple inheritance of types.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 15:  How do you define an Interface ?

Ans : To define an interface in Java, you use the interface keyword. 
interface MyInterface {
    // Abstract method declarations
    void method1();
    void method2();.
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 16: How do you implement an interface ?

Ans : interface Shape {
    double calculateArea();
    double calculatePerimeter();
}
class Circle implements Shape {
    private double radius;
    public Circle(double radius) {
        this.radius = radius;
    }
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 17:  Can you explain a few tricky things about interfaces ?

Ans : 1.Implementation Flexibility: Interfaces allow classes to provide different implementations for the same interface, enabling behavior customization.
      2.Multiple Interface Implementation: A class can implement multiple interfaces, inheriting and providing implementation for multiple sets of behaviors.
      3.Default Methods: Interfaces can have default methods with a provided implementation, allowing for backward compatibility when new methods are added to the interface.
      4.Constant Fields: Interfaces can contain constant fields that are implicitly static and final. They can be accessed directly using the interface name.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 18 : Can you extend an interface ?

Ans : Yes, an interface can be extended by using the extends keyword. When one interface extends another, it inherits the methods and constants from the parent interface.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 19 : Can a class implement multiple interfaces ?

Ans : Yes, a class can implement multiple interfaces in Java. This means that a single class can inherit and provide the implementation for multiple sets of behaviours defined by different interfaces.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 20 : What is an Abstract Class ?

Ans : An abstract class in Java is a class that cannot be instantiated and serves as a blueprint for other classes. It can contain abstract methods (methods without implementation) and regular methods with implementation. Abstract classes are used to define common characteristics and behaviors that derived classes can inherit and override. They provide a level of abstraction and serve as a foundation for class hierarchies.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 21 : When do you use an Abstract Class ?

Ans : 1.When you want to provide a common base implementation for a group of related classes.
      2.When you want to define methods that must be implemented by the derived classes.
      3.When you want to create a class hierarchy where some methods have a default implementation but can be overridden by derived classes.
      4.When you want to achieve a higher level of abstraction and provide a common interface for a set of related classes.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 22 : How do you define an Abstract Method ?

Ans : To define an abstract method in Java.Use the abstract keyword before the method declaration.Abstract methods have no implementation and end with a semicolon.Abstract methods are declared in an abstract class or an interface.Derived classes that extend the abstract class or implement the interface must provide an implementation for the abstract method.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 23 : Compare Abstract Class vs Interfaces ?

Ans : If we compare, abstract classes provide a way to define common behavior and allow partial implementation, while interfaces define a contract for classes to implement. Abstract classes support inheritance and have more flexibility, while interfaces support multiple implementations and enforce method implementation.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 24 : What is a Constructor?

Ans : A constructor in Java is a special method that is used to initialize objects of a class. It has the same name as the class and is automatically called when an object is created. Its purpose is to set the initial state of the object.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 25 :  What is a Default Constructor?

Ans : A default constructor is a constructor that is automatically provided by the Java compiler when no explicit constructors are defined in a class. It has no parameters and an empty body.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 26 : Will this code compile?

Ans : To call a superclass constructor from a constructor in Java, you use the keyword super. Specifically, you use the super() syntax to invoke the superclass constructor. This allows you to initialize the inherited members of the superclass before executing the code in the subclass constructor.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 27 :  What do you call a SuperClass Constructor from a Constructor?

Ans : To call a superclass constructor from a constructor in Java, you use the keyword super. Specifically, you use the super() syntax to invoke the superclass constructor. This allows you to initialize the inherited members of the superclass before executing the code in the subclass constructor.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 28 : Will this code Compile?

Ans : 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 29 : What is the use of this()?

Ans : The use of this() in Java is to invoke another constructor within the same class. It is used to reuse code and provide different constructors with different parameters.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 30 : Can a constructor be called directly from a method?

Ans : No, a constructor cannot be called directly from a method in Java. Constructors are special methods that are automatically called when an object is created using the new keyword.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 31 : Is a super class constructor called even when there is no explicit call from a subclass constructor ?

Ans : Yes, a superclass constructor is always called even when there is no explicit call from a subclass constructor. If a subclass constructor does not explicitly invoke a superclass constructor using the super() statement, the compiler automatically inserts an implicit call to the default (no-argument) constructor of the superclass. However, if the superclass does not have a default constructor and only has parameterized constructors, the subclass constructor must explicitly call one of the superclass constructors using the super() statement.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 32 : Write Difference between compile time and run time polymorphism ?
Ans : Compile-time polymorphism (Static polymorphism):
1.Resolved at compile-time based on the method signatures.
2.Achieved through method overloading.
3.Examples include method overloading and constructor overloading.

Runtime polymorphism (Dynamic polymorphism):
1.Resolved at runtime based on the actual type of the object.
2.Achieved through method overriding.
3.Examples include method overriding and polymorphic behavior of subclasses.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Part 5 - (Advanced OOPs)


Write Difference between compile time and run time polymorphism ?

Ans : Compile-time polymorphism (Static polymorphism):
1.Resolved at compile-time based on the method signatures.
2.Achieved through method overloading.
3.Examples include method overloading and constructor overloading.

Runtime polymorphism (Dynamic polymorphism):
1.Resolved at runtime based on the actual type of the object.
2.Achieved through method overriding.
3.Examples include method overriding and polymorphic behavior of subclasses.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : What is the use of instanceof Operator in Java?

Ans : The instanceof operator in Java is used to check if an object belongs to a specific class or is an instance of a particular class or interface. It returns a boolean value indicating whether the object is of the specified type or not. This operator is useful for type checking, type casting, and implementing conditional logic based on the type of an object at runtime.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : What is Coupling?

Ans : Coupling refers to the degree of interdependence between modules or components in a software system. It measures how closely one component is connected or relies on another component. In general, low coupling is desired as it promotes modular and maintainable code. High coupling can lead to code fragility and difficulties in making changes.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : What is Cohesion?

Ans : Cohesion refers to the degree of functional relatedness and unity within a module or component. It measures how well the elements within a module work together towards a common objective. High cohesion indicates that the module has a clear and focused purpose, with closely related functionality grouped together. This promotes code readability, maintainability, and reusability. Low cohesion suggests that the module has scattered or unrelated responsibilities, making the codebase harder to understand and maintain.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 5:  What is Encapsulation?

Ans : Encapsulation is a principle in object-oriented programming that involves bundling data and methods together within a class. It allows for the hiding of internal details and provides a public interface to interact with the object. This promotes data security, code maintainability, and helps in achieving abstraction and modular design.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6: What is an Inner Class?

Ans : An inner class is a class that is defined within another class. It is a way to logically group classes together and establish a close relationship between them. Inner classes have access to the members (fields and methods) of the outer class and can be used to encapsulate related functionality. They are often used to implement data structures, listeners, and other design patterns.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7: What is a Static Inner Class?

Ans : A static inner class is a nested class that is declared with the "static" keyword. It belongs to the outer class itself, rather than an instance of the outer class. A static inner class can be accessed without creating an instance of the outer class. It can have its own static members and methods, separate from any instances of the outer class. Static inner classes are commonly used for grouping utility classes, constants, or helper classes that are closely related to the outer class.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : Can you create an inner class inside a method?

Ans : No, you cannot create an inner class inside a method. Inner classes are typically defined within the scope of an outer class, either at the class level or within another inner class. They cannot be directly defined inside a method.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 9 : What is an Anonymous Class?

Ans : An anonymous class is a class that is declared and instantiated at the same time, without explicitly giving it a name. It is used when you need to create a one-time implementation of an interface or extend a class without creating a separate class file. Anonymous classes are typically used for event handling, callbacks, and small implementations. They are defined inline and can override methods or implement interfaces directly within their declaration.



---------------------------------------------------------------------------------------------------------------------------------------------------------------------



Part 6: (Modifiers)



Problem 1 : What is the default class modifier?

Ans : The default class modifier, also known as package-private or package access, is a level of access that is applied when no access modifier is explicitly specified for a class. It means that the class is accessible only within the same package (directory). Classes with default access can be accessed by other classes within the same package, but not from classes in other packages.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 2 : What is a private access modifier?

Ans : The private access modifier is the most restrictive access level in Java. It restricts the accessibility of a class member (field, method, or nested class) to within the same class only. Members marked as private cannot be accessed or inherited by other classes, even within the same package. It ensures that the member is encapsulated and can only be used internally within the class it is declared in.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : What is the default or package access modifier?

Ans : The default or package access modifier is a level of access that is applied when no access modifier is explicitly specified for a class, method, or field. It means that the member is accessible within the same package (directory). Members with default access can be accessed by other classes within the same package, but not from classes in other packages. It provides a level of encapsulation within the package and is the default access level if no access modifier is specified.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : What is a protected access modifier?

Ans : The protected access modifier allows the member (field, method, or nested class) to be accessed within the same package or by subclasses, even if they are in a different package. It provides a level of access that is more restrictive than public but less restrictive than private or default. Protected members are primarily used for inheritance and allow subclasses to access and override them.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 5:  What is a public access modifier?

Ans : The public access modifier is the least restrictive access level in Java. It allows the member (field, method, or nested class) to be accessed from any other class or package. Public members are visible to all classes, regardless of their location. This access modifier is typically used when you want a member to be widely accessible and usable throughout your codebase.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6: What access types of variables can be accessed from a Class in Same Package?

Ans : From a class in the same package
1.These variables can be accessed directly from any class within the same package. No explicit access modifier is required.
2.These variables can be accessed directly from any class within the same package. They can also be accessed by subclasses, even if they are in different packages.
3. These variables can be accessed directly from any class within the same package.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7:  What access types of variables can be accessed from a Class in Different Package?

Ans : From a class in a different package, only variables with public access modifier can be accessed directly. Variables with default (package) access, protected, and private access modifiers cannot be accessed from a class in a different package unless appropriate getters and setters are provided.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : What access types of variables can be accessed from a Subclass in Same Package?

Ans : From a subclass in the same package:

1.These variables can be accessed directly from the subclass.
2.These variables can be accessed directly from the subclass or any other subclass in the same package.
3.These variables can be accessed directly from the subclass since they are in the same package.
4.These variables cannot be accessed directly from the subclass. They are only accessible within the class in which they are declared.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 9 : What access types of variables can be accessed from a Subclass in a Different Package?

Ans : 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 10 : What is the use of a final modifier in a class?

Ans : The use of the final modifier in a class is to indicate that the class cannot be subclassed. It prevents any other class from extending or inheriting from the final class. This is useful when you want to create a class with a fixed implementation that should not be altered or extended.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 11 : What is the use of a final modifier on a method?

Ans : The use of the final modifier on a method is to prevent it from being overridden by any subclasses. This ensures that the method's implementation cannot be changed, providing stability and preventing unintended modifications to critical behavior.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 12 : What is a Final Variable ?

Ans : A final variable is a variable that cannot be reassigned once it is initialized. Its value remains constant throughout the program execution.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 13 : What is a Final Argument ?

Ans : A final argument is a parameter of a method or constructor that is marked as final. It means that the value of the argument cannot be changed within the method or constructor.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 14 : What is a Static Variable ?

Ans : A static variable, also known as a class variable, is a variable that belongs to the class itself rather than to any specific instance of the class. It is shared among all instances of the class and can be accessed using the class name.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Part 7 : (Collections)



Problem 1 : Why do we need Collections in Java?

-> Collections in Java provide a framework that allows developers to store and manipulate groups of objects. Before the introduction of the Collection Framework, the standard methods for grouping Java objects were Arrays or Vectors, or Hashtables, which had no common interface.he Collection Framework provides a unified architecture for storing and manipulating a group of objectsThe Collection Framework can achieve all the operations that you perform on data such as searching, sorting, insertion, manipulation, and deletion


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problem 2 : What are the important interfaces in the Collection Hierarchy?

-> The important interfaces in the Collection Hierarchy are the Collection interface and the Map interface, which are the two main "root" interfaces of Java collection classes. The Collection interface is the foundation of the Java Collections Framework and encapsulates different types of collections such as Set, List, Queue, and Deque. The Map interface is used to store key-value pairs and is implemented by classes such as HashMap, TreeMap, and LinkedHashMap.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : What are the important methods that are declared in the Collection Interface?

-> The Collection interface is a member of the Java Collections Framework and declares several methods that every collection will have. Some of the most important methods declared in the Collection interface are:
add(Object obj): Adds an element to a collection.
addAll(Collection c): Adds all elements of a collection to another collection.
remove(Object obj): Removes an element from a collection.
removeAll(Collection c): Removes all elements of a collection from another collection.
size(): Returns the number of elements in a collection.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : Can you explain briefly about the List Interface?

-> The List interface in Java provides a way to store an ordered collection of objects in which duplicate values can be stored. It is a child interface of Collection and is found in the java.util package. The List interface provides four methods for positional (indexed) access to list elements. These methods are:
get(int index): Returns the element at the specified position in this list.
set(int index, E element): Replaces the element at the specified position in this list with the specified element.
add(E element): Appends the specified element to the end of this list.
remove(int index): Removes the element at the specified position in this list.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 5 : Explain about ArrayList with an example?

-> ArrayList is a resizable array implementation of the List interface. It is found in the java.util package. ArrayList provides all the optional List operations and permits all elements, including null. 
public class Shop{
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<String>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        System.out.println(fruits);
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6 : Can an ArrayList have Duplicate elements?

-> Yes, an ArrayList can have duplicate elements.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7 : How do you iterate around an ArrayList using Iterator?

-> public class Example {
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<String>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
We can iterate using an Iterator object  the iterator() method of the ArrayList class. it iterates over the ArrayList using a while loop and prints each element using the next() method of the Iterator object.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : How do you sort an ArrayList?

->   we can sorts an ArrayList using the sort() method of the Collections class.

List<String> numbers = new ArrayList<String>(); numbers.add("one"); 

numbers.add("two");
 numbers.add("three");
 numbers.add("four"); 

System.out.println(numbers);

 alphabetically Collections.sort(numbers);

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 9 : How do you sort elements in an ArrayList using Comparable interface?

->  First we have to implement the comparable interface and then we are making get name method and then we are overriding the compare to method  and then we are adding data to Arraylist and then we are sorting and with for loop we are getting every name with getname method
public class Example implements Comparable<Example> {
    private String name;

    public Example(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public int compareTo(Example o) {
        return this.name.compareTo(o.getName());
    }

    public static void main(String[] args) {
        ArrayList<Example> examples = new ArrayList<Example>();
        examples.add(new Example("Orange"));
        examples.add(new Example("Apple"));
        examples.add(new Example("Banana"));

        Collections.sort(examples);

        for (Example example : examples) {
            System.out.println(example.getName());
        }
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 10 : How do you sort elements in an ArrayList using Comparator interface?

-> o sort elements in an ArrayList using Comparator interface, you need to override the compare() method provided by the Comparator interface. After rewriting the compare() method, you need to call Collections.sort() method 

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.add(3);
list.add(1);
list.add(4);
list.add(2);

Comparator<Integer> comparator = new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
};

Collections.sort(list, comparator);

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 11 : What is Vector class? How is it different from an ArrayList?

-> It is similar to ArrayList but has two main differences:
Vector is synchronized while ArrayList is not.
Vector increments its size by doubling it while ArrayList increments its size by half of its length.
This means that Vector is slower than ArrayList because it holds other threads in a runnable or non-runnable state until the current thread releases the lock of the object

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 12 : What is LinkedList? What interfaces does it implement? How is it different from an ArrayList?

-> The LinkedList class is a collection that can contain many objects of the same type, just like ArrayList. It is backed by a doubly-linked list and has all of the same methods as the ArrayList class because they both implement the List interface.
The main difference between LinkedList and ArrayList is that LinkedList uses a doubly-linked list to store its elements while ArrayList uses an array. This means that LinkedList is better suited for adding or removing elements from the middle of the list because it does not require shifting any elements. However, it is slower than ArrayList for random access because it does not support fast random access.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 13 : Can you briefly explain about the Set Interface?
-> The Set interface is an unordered collection of objects in which duplicate values cannot be stored. It has several implementations including HashSet, LinkedHashSet, and TreeSet.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 14 : What are the important interfaces related to the Set Interface?
-> The Set interface extends the Collection interface and has no interfaces that extend it. However, there are several interfaces that are related to the Set interface including SortedSet and NavigableSet.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 15 : What is the difference between Set and SortedSet interfaces?
-> The Set interface is an unordered collection of objects in which duplicate values cannot be stored. The SortedSet interface is a subinterface of Set that provides a total ordering on its elements. This means that the elements in a SortedSet are ordered based on their natural ordering or based on a Comparator that is provided when the SortedSet is created.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 16 : Can you give examples of classes that implement the Set Interface?
-> Some classes that implement the Set interface include HashSet, LinkedHashSet, and TreeSet.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 17 : What is a HashSet?
-> A HashSet is a collection of items where every item is unique, and it is found in the java.util package. It stores the elements by using a mechanism called hashing and contains unique elements only. HashSet allows null value and doesn’t maintain the insertion order. It is the best approach for search operations.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 18 : What is a LinkedHashSet? How is different from a HashSet?
-> A LinkedHashSet is an ordered version of HashSet that maintains a doubly-linked List across all elements. It allows us to maintain the insertion order of the elements. HashSet is an unordered & unsorted collection of the data set, whereas LinkedHashSet is an ordered and sorted collection of HashSet. HashSet does not provide any method to maintain the insertion order while LinkedHashSet maintains the insertion order of the elements.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 19 : What is a TreeSet? How is different from a HashSet?
-> A TreeSet is a sorted set implementation that uses a tree structure such as Red-Black tree. It is similar to HashSet but it maintains elements in a sorted order. HashSet is faster than TreeSet because it uses hashing to store elements while TreeSet uses a tree structure

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 20 : Can you give examples of implementations of NavigableSet?
-> Some examples of implementations of NavigableSet are:
TreeSet
ConcurrentSkipListSet
SubSet
DescendingSet

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 21 : Explain briefly about Queue Interface?
-> Queue is an interface in Java that represents a collection designed for holding elements prior to processing. It is an ordered list of objects with its use limited to inserting elements at the end of the list and deleting elements from the start of the list, i.e., it follows the FIFO (First In First Out) principle. Some of the methods defined by Queue are add(), offer(), remove(), poll(), peek() and element().

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 22 : Can you briefly explain about the Map Interface?
-> Map is an interface in Java that represents a collection of key-value pairs where each key is unique. It provides methods for adding, removing and searching for elements based on their keys. Some of the methods defined by Map are put(), get(), remove(), containsKey(), containsValue() and size().

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 23 : What is difference between Map and SortedMap?
-> Map is an interface in Java that represents a collection of key-value pairs where each key is unique. SortedMap is a subinterface of Map that maintains its entries in ascending order based on the keys. Some of the methods defined by SortedMap are firstKey(), lastKey(), subMap(), headMap(), tailMap() and comparator().

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 24 : What is a HashMap?
->HashMap is a class in Java that implements the Map interface and provides a way to store and retrieve objects based on their keys. It uses a hash table to store the key-value pairs and provides constant-time performance for basic operations such as get() and put(). Some of the methods defined by HashMap are put(), get(), remove(), containsKey(), containsValue() and size().

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 25 : What are the different methods in a Hash Map?
-> Some of the methods defined by HashMap are put(), get(), remove(), containsKey(), containsValue() and size().

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 26 : What is a TreeMap? How is different from a HashMap?
-> TreeMap is a class in Java that implements the SortedMap interface and provides a way to store and retrieve objects based on their keys. It uses a red-black tree to store the key-value pairs and maintains its entries in ascending order based on the keys. Some of the methods defined by TreeMap are put(), get(), remove(), containsKey(), containsValue(), firstKey(), lastKey(), subMap(), headMap(), tailMap() and comparator().
The main difference between HashMap and TreeMap is that HashMap does not maintain any order of its elements while TreeMap maintains its entries in ascending order based on the keys.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Part 8 : (Exceptions)


Problem 1 : Why is Exception Handling important?

-> Exception handling is important because it helps to prevent your program from crashing when an error occurs. It allows you to gracefully handle errors and take appropriate actions instead of letting your program terminate abruptly. Some of the benefits of exception handling are that it makes your code more robust, easier to debug and maintain, and more user-friendly.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : What design pattern is used to implement Exception handling Features in most languages?

-> The Chain of Responsibility pattern is often used to implement exception handling features in most languages. In this pattern, a chain of objects is created to handle a request. If one object cannot handle the request, it passes it on to the next object in the chain until the request is handled or there are no more objects in the chain.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : What is the need for finally block?

-> The finally block is used to execute code that must be run regardless of whether an exception was thrown or not. It is typically used to release resources that were acquired in a try block, such as closing a file or database connection.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : In what scenarios is code in finally not executed?
-> There are several scenarios where the finally block may not be executed. These include:
Code in finally is NOT executed only in two situations.
 If exception is thrown in finally.
 If JVM Crashes in between (for example, System.exit()).


Problem 5 : Will finally be executed in the program below?

-> private static void method2() {
			Connection connection = new Connection();
			connection.open();
			try {
					// LOGIC
					String str = null;
					str.toString();
					return;
			} catch (Exception e) {
		
					System.out.println("Exception Handled - Method 2");
					return;
			} finally {
					connection.close();
			}
}

Yes. It will be. Finally will be executed even when there is a return statement in try or catch.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6 : Is try without a catch is allowed?

-> Yes

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7 : Is try without catch and finally allowed?

-> No

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : Can you explain the hierarchy of Exception Handling classes?

-> The class at the top of the exception class hierarchy is the Throwable class, which is a direct subclass of the Object class. Throwable has two direct subclasses – Exception and Error. The Exception class is used for exception conditions that the application may need to handle. The Error class is used by the JVM to indicate errors that are not recoverable by applications

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 9 : What is the difference between Error and Exception?

-> Error
Error is used in situations when there is nothing a programmer can do about an error. 
Ex: StackOverflowError, OutOfMemoryError.

Exception
Exception is used when a programmer can handle the exception.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 10 : What is the difference between Checked Exceptions and Unchecked Exceptions?
-> Un-Checked Exception
RuntimeException and classes that extend RuntimeException are called unchecked 
exceptions. 
For Example: RuntimeException,UnCheckedException,UnCheckedException2 are 
unchecked or RunTime Exceptions. There are subclasses of RuntimeException 
(which means they are subclasses of Exception also.)

Checked Exception
Other Exception Classes (which don’t fit the earlier definition). These are also called Checked Exceptions.
Exception, CheckedException1,CheckedException2 are checked exceptions. They are subclasses of
Exception which are not subclasses of RuntimeException.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 11 : How do you throw an exception from a method?

-> To throw an exception from a method, you can use the throw keyword in Java. The throw keyword is used to explicitly throw an exception from a method or any block of code. We can throw either checked or unchecked exception.

public void myMethod() throws IOException {
    // code that might throw an IOException
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 12 : What happens when you throw a Checked Exception from a method ?
-> Let us now try to change the method addAmounts to throw an Exception instead of RuntimeException. It
gives us a compilation error.

class AmountAdder {
		static Amount addAmounts(Amount amount1, Amount amount2) {
				if (!amount1.currency.equals(amount2.currency)) {
						throw new Exception("Currencies don't match");// COMPILER ERROR!
// Unhandled exception type Exception
				}
				return new Amount(amount1.currency, amount1.amount + amount2.amount);
		}
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 13 : What are the options you have to eliminate compilation errors when handlingchecked exceptions?

-> You can eliminate compilation errors when handling checked exceptions by either declaring the function using the throw keyword to avoid a Compilation error or by using a try-catch block

import java.io.*;
public class Main {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = null;
        fis = new FileInputStream("C:/test.txt");
        int k;
        while ((k = fis.read()) != -1) {
            System.out.print((char) k);
        }
        fis.close();
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 14 : How do you create a Custom Exception?
-> To create a custom exception in Java, we have to extend the java.lang.Exception class
public class IncorrectFileNameException extends Exception {
    public IncorrectFileNameException(String errorMessage) {
        super(errorMessage);
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 15 : How do you handle multiple exception types with same exception handling block?
-> In Java, you can use vertical bar (|) to separate multiple exceptions in catch block
try {
    // some code
} catch (IOException | SQLException e) {
    // handle both exceptions
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 16 : Can you explain about try with resources?
-> Consider the example below. When the try block ends the resources are automatically released. We do
not need to create a separate finally block.

try (BufferedReader br = new BufferedReader(new FileReader("FILE_PATH")))
{
				String line;
				while ((line = br.readLine()) != null) {
						System.out.println(line);
				}
} catch (IOException e) {
			e.printStackTrace();
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 17 : How does try with resources work?
-> try-with-resources is available to any class that implements the AutoCloseable interface. In the above
example BufferedReader implements AutoCloseable interface.

public interface AutoCloseable {
				void close() throws Exception;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 18 : Can you explain a few Exception Handling Best Practices?

-> First of all : In all above examples we have not followed an Exception Handling good practice(s). We
were trying to give quick examples. So here is a list of best practices.

• Never Hide Exceptions. At the least log them. printStactTrace method prints the entire stack
trace when an exception occurs. If you handle an exception, it is always a good practice to log
the trace.

• Do not use exception handling for flow control in a program. They have a significant
performance impact.

• Think about the user. What does the user want to see if there is an exception?

• Think about the support developer. What does the support developer need to debug the
exception?

• Think about the calling method. Can the calling method do something about the exception being
thrown? If not, create un checked exceptions. For example, Spring Framework chooses to make
most of the jdbc exceptions as unchecked exceptions because , in most cases, there is nothing
that a caller of the method can do about a jdbc exception.

• Have global exception handling.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Part 8 : (Threads)

Problem 1 : What is the need for Threads in Java?

-> Threads in Java are used to perform multiple things all at once and allow us to do things more quickly in Java. When various multiple threads are executed at the same time, this process is known as multi-threading. Threads help you to achieve parallelism in Java program

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : How do you create a thread?
->   Creating a Thread class in Java can be done in two ways. Extending Thread class 
and implementing Runnable interface. Let’s create the BattingStatisticsThread 
extending Thread class and BowlingStatisticsThread implementing Runnable 
Interface.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : How do you create a thread by extending Thread class?
-> Thread class can be created by extending Thread class and implementing the public void run() method. Look at the example below: A dummy implementation for BattingStatistics is provided which counts from 1 to 1000. 

class BattingStatisticsThread extends Thread { 	
//run method without parameters 		
public void run() { 				
for (int i = 0; i < 1000; i++) 						System.out.println("Running Batting Statistics Thread "+ i); 	
} }

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : How do you create a thread by implementing Runnable interface?
-> Thread class can also be created by implementing Runnable interface and implementing the method declared in Runnable interface “public void run()”. Example below shows the Batting Statistics Thread implemented by implementing Runnable interface

class BowlingStatisticsThread implements Runnable { 
//run method without parameters
 public void run() { 
      for (int i = 0; i < 1000; i++) 						System.out.println("Running Bowling Statistics Thread "+ i);
} }


--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 5 : How do you run a Thread in Java?
-> To run a thread in Java, you can use the start() method. The start() method starts the execution of a thread. When start() is called on a Thread object, it creates a separate call stack for that Thread Then it calls the run() method The code inside the run() method is executed in a separate thread

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6 : What are the different states of a Thread?
-> The different states of a Thread are:
New
Runnable
Blocked/Waiting
Timed Waiting
Terminated.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7 : What is priority of a thread? How do you change the priority of a thread?
-> In Java, a thread’s priority is an integer in the range 1 to 10. The larger the integer, the higher the priority. The thread scheduler uses this integer from each thread to determine which one should be allowed to execute. The Thread class defines three types of priorities: Minimum priority; Normal priority; Maximum priority.
To change the priority of a thread, you can use setPriority() method. The setPriority() method sets the priority of a thread. It takes an integer value as an argument. The value should be between 1 and 10.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : What is ExecutorService?
-> The java.util.concurrent.ExecutorService interface is a new way of executing 
tasks asynchronously in the background. An ExecutorService is very similar to a 
thread pool.

Problem 9 : Can you give an example for ExecutorService?
-> ExecutorService executorService = Executors.newFixedThreadPool(10);
executorService.execute(new Runnable() {
    public void run() {
        System.out.println("Asynchronous task");
    }
});
executorService.shutdown();

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 10 : Explain different ways of creating Executor Services.
-> There are three ways of creating executor services. Below example shows the three 
different ways. executorService1 can execute one task at a time. executorService2 
can execute 10 tasks at a time. executorService3 can execute tasks after certain 
delay or periodically.

// Creates an Executor that uses a single worker thread operating off an
// unbounded queue.
ExecutorService executorService1 = Executors.newSingleThreadExecutor();

// Creates a thread pool that reuses a fixed number of threads
// operating off a shared unbounded queue. At any point, the parameter
// specifies the most threads that will be active processing tasks.
ExecutorService executorService2 = Executors.newFixedThreadPool(10);

// Creates a thread pool that can schedule commands to run after a
// given delay, or to execute periodically.
ExecutorService executorService3 = Executors.newScheduledThreadPool(10);

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 11 : How do you check whether an ExecutionService task executed successfully?
-> We can use a Future to check the return value. Below example shows how it can be done. Future get method would return null if the task finished successfully.

Future future = executorService1.submit(new Runnable() { 				public void run() { 						
System.out .println("From executorService1"); 
} 		
}); 		
future.get(); // returns null if the task has finished correctly.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 12 : What is Callable? How do you execute a Callable from ExecutionService?
-> Callable is an interface that is similar to Runnable, but it returns a value and can throw an exception. To execute a Callable from ExecutorService, you can use the submit() method
ExecutorService executorService = Executors.newSingleThreadExecutor();
Future<String> future = executorService.submit(new Callable<String>() {
    public String call() throws Exception {
        return "Hello from Callable";
    }
});
System.out.println("future.get() = " + future.get());
executorService.shutdown();

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 9 : (Serialization)

Problem 1 : What is Garbage Collection?
-> Garbage Collection is a name given to automatic memory management in Java. Aim of Garbage
Collection is to Keep as much of heap available (free) for the program as possible. JVM removes objects
on the heap which no longer have references from the heap.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 2 : Can you explain Garbage Collection with an example?
-> Garbage collection is a process of automatically freeing up memory that is no longer being used by a program. In Java, garbage collection is performed automatically by the JVM
public class MyClass {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj = null;
        System.gc();
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 3 : When is Garbage Collection run?
-> Garbage Collection runs at the whims and fancies of the JVM (it isn't as bad as that). Possible situations
when Garbage Collection might run are
• when available memory on the heap is low
• when cpu is free
What are best practices on Garbage Collection?
->Programmatically, we can request (remember it’s just a request - Not an order) JVM to run Garbage
Collection by calling System.gc() method.

JVM might throw an OutOfMemoryException when memory is full and no objects on the heap are eligible
for garbage collection.

finalize() method on the objected is run before the object is removed from the heap from the garbage
collector. We recommend not to write any code in finalize();

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 4 : What are Initialization Blocks?
->Initialization Blocks - Code which runs when an object is created or a class is loaded
There are two types of Initialization Blocks
Static Initializer: Code that runs when a class is loaded.
Instance Initializer: Code that runs when a new object is created.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 5 : What is a Static Initializer?
-> A static initializer is a block of code that is executed when a class is loaded into memory It is used to initialize static variables
public class MyClass {
    static {
        // code here
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 6 : What is an Instance Initializer Block?
->An instance initializer block is a block of code that is executed when an instance of a class is created. It is used to initialize instance variables
public class MyClass {
    {
//code
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 7 : What is Serialization?
-> Serialization helps us to save and retrieve the state of an object.
• Serialization => Convert object state to some internal object representation.
• De-Serialization => The reverse. Convert internal representation to object.
Two important methods
• ObjectOutputStream.writeObject() // serialize and write to file
• ObjectInputStream.readObject() // read from file and deserialize

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 8 : How do you serialize an object using Serializable interface?
-> To serialize an object using Serializable interface in Java, we need to implement the Serializable interface in our class. Once we have implemented this interface, we can use the ObjectOutputStream class to serialize our object
import java.io.*;

public class MyClass implements Serializable {
    // fields and methods here
}

// Serialization
MyClass obj = new MyClass();
FileOutputStream fileOut = new FileOutputStream("filename.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(obj);
out.close();
fileOut.close();

// Deserialization
MyClass obj = null;
FileInputStream fileIn = new FileInputStream("filename.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
obj = (MyClass) in.readObject();
in.close();
fileIn.close();
How do you de-serialize in Java?
-> Below example show how a object can be deserialized from a serialized file. A
rectangle object is deserialized from the file Rectangle.ser

FileInputStream fileInputStream = new FileInputStream("Rectangle.ser");
ObjectInputStream objectInputStream = new ObjectInputStream(
fileInputStream);
Rectangle rectangle = (Rectangle) objectInputStream.readObject();
objectInputStream.close();
System.out.println(rectangle.length);// 5
System.out.println(rectangle.breadth);// 6
System.out.println(rectangle.area);// 30

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 9 : What do you do if only parts of the object have to be serialized?
-> We mark all the properties of the object which should not be serialized as transient. Transient attributes in an object are not serialized. Area in the previous example is a calculated value. It is unnecessary to serialize and deserialize. We can calculate it when needed. In this situation, we can make the variable transient. Transient variables are not serialized. (transient int area;)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Problem 10 : How do you serialize a hierarchy of objects?

-> Objects of one class might contain objects of other classes. When serializing and de-serializing, we might need to serialize and de-serialize entire object chain. All classes that need to be serialized have to implement the Serializable interface. Otherwise, an exception is thrown. Look at the class below. An object of class House contains an object of class Wall.

Are the values of static variables stored when an object is serialized?
->Static Variables are not part of the object. They are not serialized. 




New Questions

https://youtu.be/q712md1F6Dk?si=_RppiZT2PYMhZwct

Answer all these in DUBX framework

1. Details about tomcat server.

-> It is designed to handle Java Servlets and JavaServer Pages (JSP) applications, providing a web server environment for running Java-based web applications. Tomcat is one of the most popular and widely used web application servers for Java applications.

2. Which is the most comfortable topic to you in java

3. How much you rate yourself in java

-> 9.99/10

4. How do we achieve encapsulation in java.

-> fields should be private and getter setter methods to be made

5. Difference between global variable and local variable.

6. Details about synchronized keyword. 

-> ATM real-life example

7. Difference between list and set

8. Difference between ArrayList and Vector

-> ArrayList is not synchronized          |          Vector is synchronized
   
   Arraylist performance is fast          |          Vector performance is low    

9. Difference between hashMap and hashTable

->  HashMap is non synchronized.          |           HashMap is non synchronized. 
                                          |
    HashMap is fast.                      |           Hashtable is slow.
	                                      |
	HashMap inherits AbstractMap class.   |           Hashtable inherits Dictionary class.

10. What is JDBC

-> Java Database Connnectivitity

11. Can we change database from mySQL to Oracle in JDBC is there will be any problem

12. What are the steps in JDBC we need to follow in order to connect to the database (do that in pc and show me)

13. Why we give the @Service,@Controller annotation

14. Why we use getter setter

15. What will happen if i remove the public keyword of main method

16. Write a code to count characters in a string without any default method



Core Java Interview Questions (https://youtu.be/NNYRIXPxFIk?si=3wG7JxzsyCAMv36)


1. What is the difference JDK,JRE and JVM?

-> JVM stands for Java Virtual Machine and it is responsible to convert source code to bytecode

   JRE stands for Java Runtime Environment and it provides JVM and libraries
   
   JDK stands for Java Development Kit and it provides Javac , Debugging tools , JRE + Development tools


2. How many types of memory areas are allocated by JVM?

-> Class Area : Stores per-class structures like the runtime constant fields,pools,methods

   Heap : Runtime data area where memory is allocated to objects

   Stack : 

   Program counter Register : contains the address of the currently executing class

   Native Method Stack : Holds all native methods used in the application


3. Is Java is 100% Object Oriented Programming , if no then why?

-> No because it supports primitive data types , static members 

4. Why main method is static? Why main method should be public?

-> because the Object is not required to call the static method if we make the main method non static jvm will have to create its object first and then call main method which will lead to the extra memory allocation  

   because main method serve as entry point for a java application and making it public it will be accessible and executable outside of the class.

5. Can we execute a program without main method?

-> Yes , it was possible before 1.7 using static block but now it is not possible.

6. How is exception handling implemented in Java?

-> Java uses try catch block to handle exception
    
7. Can you catch multiple exceptions in a single try catch block?

-> Yes from java 7 you can do that

8. What are the main principles of object-oriented programming?

-> encapsulation ,inheritance ,polymorphism and abstraction (EIPA)

9. What is the difference between abstract class and interface?


-> Abstract classes can have both abstract and concrete methods      |        interfaces can only have abstract methods 

   Can have instance variables (fields) with any access modifiers    |        Cannot have instance variables
   
   Supports single inheritance (extends one class)                   |        Supports multiple inheritance (implements multiple interfaces)



10. What is the use of static keyword in java?

-> 3 reasons to use static keyword
   
   i. When we want to make something that most of the time it's value will be constant then we can use static keyword there.

   ii. If we want to access or call a variable or method without help of any object creation there we will use static keyword.   
   
   iii. Static method gets extra preference from the class that can be accesible in amy method of the class whether it is a static or not static method with class name also.


11. What is the purpose of the final keyword in java?

-> the final keyword is used to make a variable constant a method unchangeable(cannot be overridden) or a class not extensible (cannot be subclassed)

12. What is the difference between string , StringBuilder and StringBuffer?

->  String : Immutable (cannot be changed after creation)
    
	StringBuilder : Mutable 
	
	StringBuffer : Similar to StringBuilder but thread safe
	
13. What is the differnce between == and .equals in Java?

-> 	== : it is used to check the refernce (checking if two objects point to the same memory location)

    .equals() : is used for content comparison (checking if two objects have the same content or values)
	
	
14. What are the acess modifiers in Java and what do they signify?

-> public : accessible from any class 
   
   protected : accessible within the package and subclasses 
   
   default : accessible within the package 
   
   private : accessible only within the class 	
   
   
   
15. Explain the concept of method overloading.

->  Method overloading allows multiple methods with the the same name but different parameter list within the same class 

16. Difference between method overloading and method overriding 

17. What is Java collection framework?

-> The Java collection framework is a set of interfaces ,classes and algorithms that provide various data structures like list ,set ,queues and maps to store manage and manipulate collection of objects  


18. What is class loader?


19. Is Empty .java file name a valid source file name?


20.  What if I write static public void instead of public static void?


21.  What are the advantages of Packages in Java? 20) How many types of constructors are used in Java?


22.  What are the differences between the constructors and methods?


23.  Can we make constructors static?


24.  Can this keyword be used to refer static members?


25.  What is object cloning?


26.  Why is method overloading not possible by changing the return type in java?


27.  Why String is immutable in java?


28.  Can you override a private or static method in java why?


29.  Explain the concept of garbage collection in Java.

MySQL

30. What is SQL?


31. What is DDL,DML,DRL?


32. What is primary key?


33. What is Serializable and De-Serialization?


34. What is final , finally and finalised?


35. What is polymorphism with real life example?


36. What is hibernate?


37. What is Springboot?


38. What is Object?


39. What is FileInputStream and FileOutputStream?


40. What is abstraction?


41. what is super class of all class?


42. What is runtime exception and compile time exception?


43. What is the difference between thread and process?


44. What is static keyword in java?


45. What is Javac?

-> Javac is a compiler which act on source code and convert it into bytecode 

46. What is bytecode?

-> ByteCode is a machine readable code. Like 1 and 0
